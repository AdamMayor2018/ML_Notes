# 一.数据集探查检验

## 1.数据字段释义

### 1.1 查看的步骤：

1. 查看数据集有多少个字段
2. 查看数据集有多少条
3. 列出每个字段的含义
4. 查看每个字段的数据类型
5. 列出每个字段是离散型变量还是连续型变量，举例：

```python
# 离散字段
category_cols = [ 'gender', 'SeniorCitizen', 'Partner', 'Dependents',
                'PhoneService', 'MultipleLines', 'InternetService', 'OnlineSecurity', 'OnlineBackup', 
                'DeviceProtection', 'TechSupport', 'StreamingTV', 'StreamingMovies', 'Contract', 'PaperlessBilling',
                'PaymentMethod']

# 连续字段
numeric_cols = ['tenure', 'MonthlyCharges', 'TotalCharges']

# 标签
target = 'Churn'

#ID 列
ID_col = 'customerID'

# 验证是否划分能完全
assert len(category_cols) + len(numeric_cols) + 2 == tcc.shape[1]
```



### 1.2 常用的代码：

```python
df.info()
```

## 2.数据集正确性校验

### 2.1 检查某列是否有重复值(比如ID列)：

```python
df['ID'].nunique() == df.shape[0]
```

### 2.2 检查是否有重复的两行

```python
df.duplicated().sum()
```

## 3.缺失值检查

### 3.1 使用is_null()函数检查

```python
df.isnull().sum()
```

### 3.2 自定义函数

自定义函数打印每列的缺失值和缺失值比例

```python
def missing(df):
    """
        计算每列的缺失值占比
    """
    missing_number = df.isnull().sum().sort_values(ascending=False)
    missing_percent = (df.isnull().sum()/df.isnull().count()).sort_values(ascending=False)
    missing_values = pd.concat([missing_number, missing_percent], axis=1, keys=['Missing_Number', 'Missing_Percent']) 
    return missing_values
```

### 3.3 检查其他缺失值可能的情况

**方法一：**

is_null()函数的有局限性，该函数只能检测出None或者nan的情况，但有时候缺失值可能空格或者其他字符等。

有一种办法就是尝试进行类型转换：

```python
df[numeric_cols].astype(float)
```

如果报错，则可能存在某种字符在代表空值。以空格为例，列出检查方法：

```python
def find_index(data_col, val):
    """
        查询某值在某列中第一次出现位置的索引，没有则返回-1
        :param data_col:查询的列
        :param val:具体取值
    """
    val_list = [val]
    if data_col.isin(val_list).sum() == 0:
        index = -1
    else:
        index = data_col.isin(val_list).idxmax()
    return index   
```

```python
for col in numeric_cols:
    print(col, ":", find_index(df[col], " "))
```

将空格代表的字符串，转化为np.nan:

```python
df['TotalCharges'] = df['TotalCharges'].apply(lambda x:x if x!=' ' else np.nan)
```

**方法二：**

还有另一种更便捷的方法，使用pd.numeric()函数对连续变量进行转化，设置errors='coerce'，表示对于可以转换数值类型的直接转换，无法转换的用np.nan进行填充：

```python
pd.to_numeric(df.TotalCharges, errors='coerce') 
df.TotalCharges.isnull().sum()
#to_numeric函数可以自动处理无法转化的数值的数值都填补成nan
```

